//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#ifndef ROSUR_MSGS_UR_MSGS_ROBOTSTATERTMSG_CORE_H_
#define ROSUR_MSGS_UR_MSGS_ROBOTSTATERTMSG_CORE_H_

#include "ROSUr_msgs/Ur_msgs_RobotStateRTMsgData.hh"

#include <iostream>
#include <string>
#include <list>

namespace ROSUr_msgs {
	
class Ur_msgs_RobotStateRTMsgCore {
protected:
	// data structure
	ROSUr_msgsIDL::Ur_msgs_RobotStateRTMsg idl_Ur_msgs_RobotStateRTMsg;
	
public:
	// give a publicly accessible type-name for the template parameter IDL
	typedef ROSUr_msgsIDL::Ur_msgs_RobotStateRTMsg DATATYPE;
	
	#ifdef ENABLE_HASH
		static size_t generateDataHash(const DATATYPE &);
	#endif
	
	static const char* getCompiledHash();
	static void getAllHashValues(std::list<std::string> &hashes);
	static void checkAllHashValues(std::list<std::string> &hashes);
	
	// default constructors
	Ur_msgs_RobotStateRTMsgCore();
	Ur_msgs_RobotStateRTMsgCore(const DATATYPE &data);
	// default destructor
	virtual ~Ur_msgs_RobotStateRTMsgCore();
	
	const DATATYPE& get() const { return idl_Ur_msgs_RobotStateRTMsg; }
	operator const DATATYPE&() const { return idl_Ur_msgs_RobotStateRTMsg; }
	DATATYPE& set() { return idl_Ur_msgs_RobotStateRTMsg; }

	static inline std::string identifier(void) { return "ROSUr_msgs::Ur_msgs_RobotStateRTMsg"; }
	
	// helper method to easily implement output stream in derived classes
	void to_ostream(std::ostream &os = std::cout) const;
	
	// convert to xml stream
	void to_xml(std::ostream &os, const std::string &indent = "") const;
	
	// restore from xml stream
	void from_xml(std::istream &is);
	
	// User Interface
	
	// getter and setter for element Time
	inline double getTime() const { return idl_Ur_msgs_RobotStateRTMsg.time; }
	inline Ur_msgs_RobotStateRTMsgCore& setTime(const double &time) { idl_Ur_msgs_RobotStateRTMsg.time = time; return *this; }
	
	// getter and setter for element Q_target
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.q_target of type vector<double>
	 */
	inline std::vector<double>& getQ_targetRef() { return idl_Ur_msgs_RobotStateRTMsg.q_target; }
	inline std::vector<double> getQ_targetCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.q_target.begin(), idl_Ur_msgs_RobotStateRTMsg.q_target.end());
	}
	inline double getQ_targetElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.q_target[pos]; }
	inline size_t getQ_targetSize() const { return idl_Ur_msgs_RobotStateRTMsg.q_target.size(); }
	inline bool isQ_targetEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.q_target.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.q_target of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setQ_target(const std::vector<double> &q_target) { idl_Ur_msgs_RobotStateRTMsg.q_target = q_target; return *this; }
	inline bool setQ_targetElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.q_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.q_target[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertQ_targetVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.q_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.q_target.insert(idl_Ur_msgs_RobotStateRTMsg.q_target.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeQ_target(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.q_target.resize(size); }
	inline bool eraseQ_targetElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.q_target.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.q_target.erase(idl_Ur_msgs_RobotStateRTMsg.q_target.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.q_target.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearQ_target() { idl_Ur_msgs_RobotStateRTMsg.q_target.clear(); }
	
	// getter and setter for element Qd_target
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.qd_target of type vector<double>
	 */
	inline std::vector<double>& getQd_targetRef() { return idl_Ur_msgs_RobotStateRTMsg.qd_target; }
	inline std::vector<double> getQd_targetCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.qd_target.begin(), idl_Ur_msgs_RobotStateRTMsg.qd_target.end());
	}
	inline double getQd_targetElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.qd_target[pos]; }
	inline size_t getQd_targetSize() const { return idl_Ur_msgs_RobotStateRTMsg.qd_target.size(); }
	inline bool isQd_targetEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.qd_target.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.qd_target of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setQd_target(const std::vector<double> &qd_target) { idl_Ur_msgs_RobotStateRTMsg.qd_target = qd_target; return *this; }
	inline bool setQd_targetElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qd_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qd_target[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertQd_targetVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qd_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qd_target.insert(idl_Ur_msgs_RobotStateRTMsg.qd_target.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeQd_target(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.qd_target.resize(size); }
	inline bool eraseQd_targetElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.qd_target.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.qd_target.erase(idl_Ur_msgs_RobotStateRTMsg.qd_target.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.qd_target.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearQd_target() { idl_Ur_msgs_RobotStateRTMsg.qd_target.clear(); }
	
	// getter and setter for element Qdd_target
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.qdd_target of type vector<double>
	 */
	inline std::vector<double>& getQdd_targetRef() { return idl_Ur_msgs_RobotStateRTMsg.qdd_target; }
	inline std::vector<double> getQdd_targetCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.qdd_target.begin(), idl_Ur_msgs_RobotStateRTMsg.qdd_target.end());
	}
	inline double getQdd_targetElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.qdd_target[pos]; }
	inline size_t getQdd_targetSize() const { return idl_Ur_msgs_RobotStateRTMsg.qdd_target.size(); }
	inline bool isQdd_targetEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.qdd_target.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.qdd_target of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setQdd_target(const std::vector<double> &qdd_target) { idl_Ur_msgs_RobotStateRTMsg.qdd_target = qdd_target; return *this; }
	inline bool setQdd_targetElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qdd_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qdd_target[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertQdd_targetVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qdd_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qdd_target.insert(idl_Ur_msgs_RobotStateRTMsg.qdd_target.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeQdd_target(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.qdd_target.resize(size); }
	inline bool eraseQdd_targetElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.qdd_target.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.qdd_target.erase(idl_Ur_msgs_RobotStateRTMsg.qdd_target.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.qdd_target.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearQdd_target() { idl_Ur_msgs_RobotStateRTMsg.qdd_target.clear(); }
	
	// getter and setter for element I_target
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.i_target of type vector<double>
	 */
	inline std::vector<double>& getI_targetRef() { return idl_Ur_msgs_RobotStateRTMsg.i_target; }
	inline std::vector<double> getI_targetCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.i_target.begin(), idl_Ur_msgs_RobotStateRTMsg.i_target.end());
	}
	inline double getI_targetElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.i_target[pos]; }
	inline size_t getI_targetSize() const { return idl_Ur_msgs_RobotStateRTMsg.i_target.size(); }
	inline bool isI_targetEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.i_target.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.i_target of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setI_target(const std::vector<double> &i_target) { idl_Ur_msgs_RobotStateRTMsg.i_target = i_target; return *this; }
	inline bool setI_targetElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.i_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.i_target[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertI_targetVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.i_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.i_target.insert(idl_Ur_msgs_RobotStateRTMsg.i_target.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeI_target(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.i_target.resize(size); }
	inline bool eraseI_targetElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.i_target.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.i_target.erase(idl_Ur_msgs_RobotStateRTMsg.i_target.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.i_target.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearI_target() { idl_Ur_msgs_RobotStateRTMsg.i_target.clear(); }
	
	// getter and setter for element M_target
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.m_target of type vector<double>
	 */
	inline std::vector<double>& getM_targetRef() { return idl_Ur_msgs_RobotStateRTMsg.m_target; }
	inline std::vector<double> getM_targetCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.m_target.begin(), idl_Ur_msgs_RobotStateRTMsg.m_target.end());
	}
	inline double getM_targetElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.m_target[pos]; }
	inline size_t getM_targetSize() const { return idl_Ur_msgs_RobotStateRTMsg.m_target.size(); }
	inline bool isM_targetEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.m_target.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.m_target of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setM_target(const std::vector<double> &m_target) { idl_Ur_msgs_RobotStateRTMsg.m_target = m_target; return *this; }
	inline bool setM_targetElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.m_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.m_target[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertM_targetVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.m_target.size()) {
			idl_Ur_msgs_RobotStateRTMsg.m_target.insert(idl_Ur_msgs_RobotStateRTMsg.m_target.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeM_target(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.m_target.resize(size); }
	inline bool eraseM_targetElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.m_target.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.m_target.erase(idl_Ur_msgs_RobotStateRTMsg.m_target.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.m_target.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearM_target() { idl_Ur_msgs_RobotStateRTMsg.m_target.clear(); }
	
	// getter and setter for element Q_actual
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.q_actual of type vector<double>
	 */
	inline std::vector<double>& getQ_actualRef() { return idl_Ur_msgs_RobotStateRTMsg.q_actual; }
	inline std::vector<double> getQ_actualCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.q_actual.begin(), idl_Ur_msgs_RobotStateRTMsg.q_actual.end());
	}
	inline double getQ_actualElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.q_actual[pos]; }
	inline size_t getQ_actualSize() const { return idl_Ur_msgs_RobotStateRTMsg.q_actual.size(); }
	inline bool isQ_actualEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.q_actual.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.q_actual of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setQ_actual(const std::vector<double> &q_actual) { idl_Ur_msgs_RobotStateRTMsg.q_actual = q_actual; return *this; }
	inline bool setQ_actualElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.q_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.q_actual[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertQ_actualVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.q_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.q_actual.insert(idl_Ur_msgs_RobotStateRTMsg.q_actual.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeQ_actual(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.q_actual.resize(size); }
	inline bool eraseQ_actualElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.q_actual.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.q_actual.erase(idl_Ur_msgs_RobotStateRTMsg.q_actual.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.q_actual.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearQ_actual() { idl_Ur_msgs_RobotStateRTMsg.q_actual.clear(); }
	
	// getter and setter for element Qd_actual
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.qd_actual of type vector<double>
	 */
	inline std::vector<double>& getQd_actualRef() { return idl_Ur_msgs_RobotStateRTMsg.qd_actual; }
	inline std::vector<double> getQd_actualCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.qd_actual.begin(), idl_Ur_msgs_RobotStateRTMsg.qd_actual.end());
	}
	inline double getQd_actualElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.qd_actual[pos]; }
	inline size_t getQd_actualSize() const { return idl_Ur_msgs_RobotStateRTMsg.qd_actual.size(); }
	inline bool isQd_actualEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.qd_actual.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.qd_actual of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setQd_actual(const std::vector<double> &qd_actual) { idl_Ur_msgs_RobotStateRTMsg.qd_actual = qd_actual; return *this; }
	inline bool setQd_actualElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qd_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qd_actual[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertQd_actualVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.qd_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.qd_actual.insert(idl_Ur_msgs_RobotStateRTMsg.qd_actual.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeQd_actual(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.qd_actual.resize(size); }
	inline bool eraseQd_actualElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.qd_actual.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.qd_actual.erase(idl_Ur_msgs_RobotStateRTMsg.qd_actual.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.qd_actual.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearQd_actual() { idl_Ur_msgs_RobotStateRTMsg.qd_actual.clear(); }
	
	// getter and setter for element I_actual
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.i_actual of type vector<double>
	 */
	inline std::vector<double>& getI_actualRef() { return idl_Ur_msgs_RobotStateRTMsg.i_actual; }
	inline std::vector<double> getI_actualCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.i_actual.begin(), idl_Ur_msgs_RobotStateRTMsg.i_actual.end());
	}
	inline double getI_actualElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.i_actual[pos]; }
	inline size_t getI_actualSize() const { return idl_Ur_msgs_RobotStateRTMsg.i_actual.size(); }
	inline bool isI_actualEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.i_actual.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.i_actual of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setI_actual(const std::vector<double> &i_actual) { idl_Ur_msgs_RobotStateRTMsg.i_actual = i_actual; return *this; }
	inline bool setI_actualElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.i_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.i_actual[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertI_actualVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.i_actual.size()) {
			idl_Ur_msgs_RobotStateRTMsg.i_actual.insert(idl_Ur_msgs_RobotStateRTMsg.i_actual.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeI_actual(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.i_actual.resize(size); }
	inline bool eraseI_actualElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.i_actual.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.i_actual.erase(idl_Ur_msgs_RobotStateRTMsg.i_actual.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.i_actual.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearI_actual() { idl_Ur_msgs_RobotStateRTMsg.i_actual.clear(); }
	
	// getter and setter for element Tool_acc_values
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.tool_acc_values of type vector<double>
	 */
	inline std::vector<double>& getTool_acc_valuesRef() { return idl_Ur_msgs_RobotStateRTMsg.tool_acc_values; }
	inline std::vector<double> getTool_acc_valuesCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.begin(), idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.end());
	}
	inline double getTool_acc_valuesElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.tool_acc_values[pos]; }
	inline size_t getTool_acc_valuesSize() const { return idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.size(); }
	inline bool isTool_acc_valuesEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.tool_acc_values of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setTool_acc_values(const std::vector<double> &tool_acc_values) { idl_Ur_msgs_RobotStateRTMsg.tool_acc_values = tool_acc_values; return *this; }
	inline bool setTool_acc_valuesElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tool_acc_values[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertTool_acc_valuesVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.insert(idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeTool_acc_values(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.resize(size); }
	inline bool eraseTool_acc_valuesElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.erase(idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearTool_acc_values() { idl_Ur_msgs_RobotStateRTMsg.tool_acc_values.clear(); }
	
	// getter and setter for element Tcp_force
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.tcp_force of type vector<double>
	 */
	inline std::vector<double>& getTcp_forceRef() { return idl_Ur_msgs_RobotStateRTMsg.tcp_force; }
	inline std::vector<double> getTcp_forceCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.tcp_force.begin(), idl_Ur_msgs_RobotStateRTMsg.tcp_force.end());
	}
	inline double getTcp_forceElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.tcp_force[pos]; }
	inline size_t getTcp_forceSize() const { return idl_Ur_msgs_RobotStateRTMsg.tcp_force.size(); }
	inline bool isTcp_forceEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.tcp_force.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.tcp_force of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setTcp_force(const std::vector<double> &tcp_force) { idl_Ur_msgs_RobotStateRTMsg.tcp_force = tcp_force; return *this; }
	inline bool setTcp_forceElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tcp_force.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_force[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertTcp_forceVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tcp_force.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_force.insert(idl_Ur_msgs_RobotStateRTMsg.tcp_force.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeTcp_force(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.tcp_force.resize(size); }
	inline bool eraseTcp_forceElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.tcp_force.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_force.erase(idl_Ur_msgs_RobotStateRTMsg.tcp_force.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.tcp_force.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearTcp_force() { idl_Ur_msgs_RobotStateRTMsg.tcp_force.clear(); }
	
	// getter and setter for element Tool_vector
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.tool_vector of type vector<double>
	 */
	inline std::vector<double>& getTool_vectorRef() { return idl_Ur_msgs_RobotStateRTMsg.tool_vector; }
	inline std::vector<double> getTool_vectorCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.tool_vector.begin(), idl_Ur_msgs_RobotStateRTMsg.tool_vector.end());
	}
	inline double getTool_vectorElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.tool_vector[pos]; }
	inline size_t getTool_vectorSize() const { return idl_Ur_msgs_RobotStateRTMsg.tool_vector.size(); }
	inline bool isTool_vectorEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.tool_vector.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.tool_vector of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setTool_vector(const std::vector<double> &tool_vector) { idl_Ur_msgs_RobotStateRTMsg.tool_vector = tool_vector; return *this; }
	inline bool setTool_vectorElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tool_vector.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tool_vector[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertTool_vectorVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tool_vector.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tool_vector.insert(idl_Ur_msgs_RobotStateRTMsg.tool_vector.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeTool_vector(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.tool_vector.resize(size); }
	inline bool eraseTool_vectorElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.tool_vector.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.tool_vector.erase(idl_Ur_msgs_RobotStateRTMsg.tool_vector.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.tool_vector.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearTool_vector() { idl_Ur_msgs_RobotStateRTMsg.tool_vector.clear(); }
	
	// getter and setter for element Tcp_speed
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.tcp_speed of type vector<double>
	 */
	inline std::vector<double>& getTcp_speedRef() { return idl_Ur_msgs_RobotStateRTMsg.tcp_speed; }
	inline std::vector<double> getTcp_speedCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.tcp_speed.begin(), idl_Ur_msgs_RobotStateRTMsg.tcp_speed.end());
	}
	inline double getTcp_speedElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.tcp_speed[pos]; }
	inline size_t getTcp_speedSize() const { return idl_Ur_msgs_RobotStateRTMsg.tcp_speed.size(); }
	inline bool isTcp_speedEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.tcp_speed.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.tcp_speed of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setTcp_speed(const std::vector<double> &tcp_speed) { idl_Ur_msgs_RobotStateRTMsg.tcp_speed = tcp_speed; return *this; }
	inline bool setTcp_speedElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tcp_speed.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_speed[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertTcp_speedVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.tcp_speed.size()) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_speed.insert(idl_Ur_msgs_RobotStateRTMsg.tcp_speed.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeTcp_speed(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.tcp_speed.resize(size); }
	inline bool eraseTcp_speedElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.tcp_speed.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.tcp_speed.erase(idl_Ur_msgs_RobotStateRTMsg.tcp_speed.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.tcp_speed.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearTcp_speed() { idl_Ur_msgs_RobotStateRTMsg.tcp_speed.clear(); }
	
	// getter and setter for element Digital_input_bits
	inline double getDigital_input_bits() const { return idl_Ur_msgs_RobotStateRTMsg.digital_input_bits; }
	inline Ur_msgs_RobotStateRTMsgCore& setDigital_input_bits(const double &digital_input_bits) { idl_Ur_msgs_RobotStateRTMsg.digital_input_bits = digital_input_bits; return *this; }
	
	// getter and setter for element Motor_temperatures
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.motor_temperatures of type vector<double>
	 */
	inline std::vector<double>& getMotor_temperaturesRef() { return idl_Ur_msgs_RobotStateRTMsg.motor_temperatures; }
	inline std::vector<double> getMotor_temperaturesCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.begin(), idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.end());
	}
	inline double getMotor_temperaturesElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.motor_temperatures[pos]; }
	inline size_t getMotor_temperaturesSize() const { return idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.size(); }
	inline bool isMotor_temperaturesEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.motor_temperatures of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setMotor_temperatures(const std::vector<double> &motor_temperatures) { idl_Ur_msgs_RobotStateRTMsg.motor_temperatures = motor_temperatures; return *this; }
	inline bool setMotor_temperaturesElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.size()) {
			idl_Ur_msgs_RobotStateRTMsg.motor_temperatures[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertMotor_temperaturesVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.size()) {
			idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.insert(idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeMotor_temperatures(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.resize(size); }
	inline bool eraseMotor_temperaturesElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.erase(idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearMotor_temperatures() { idl_Ur_msgs_RobotStateRTMsg.motor_temperatures.clear(); }
	
	// getter and setter for element Controller_timer
	inline double getController_timer() const { return idl_Ur_msgs_RobotStateRTMsg.controller_timer; }
	inline Ur_msgs_RobotStateRTMsgCore& setController_timer(const double &controller_timer) { idl_Ur_msgs_RobotStateRTMsg.controller_timer = controller_timer; return *this; }
	
	// getter and setter for element Test_value
	inline double getTest_value() const { return idl_Ur_msgs_RobotStateRTMsg.test_value; }
	inline Ur_msgs_RobotStateRTMsgCore& setTest_value(const double &test_value) { idl_Ur_msgs_RobotStateRTMsg.test_value = test_value; return *this; }
	
	// getter and setter for element Robot_mode
	inline double getRobot_mode() const { return idl_Ur_msgs_RobotStateRTMsg.robot_mode; }
	inline Ur_msgs_RobotStateRTMsgCore& setRobot_mode(const double &robot_mode) { idl_Ur_msgs_RobotStateRTMsg.robot_mode = robot_mode; return *this; }
	
	// getter and setter for element Joint_modes
	/**
	 * Getter methods for idl_Ur_msgs_RobotStateRTMsg.joint_modes of type vector<double>
	 */
	inline std::vector<double>& getJoint_modesRef() { return idl_Ur_msgs_RobotStateRTMsg.joint_modes; }
	inline std::vector<double> getJoint_modesCopy() const {
		return std::vector<double>(idl_Ur_msgs_RobotStateRTMsg.joint_modes.begin(), idl_Ur_msgs_RobotStateRTMsg.joint_modes.end());
	}
	inline double getJoint_modesElemAtPos(const size_t &pos) const { return idl_Ur_msgs_RobotStateRTMsg.joint_modes[pos]; }
	inline size_t getJoint_modesSize() const { return idl_Ur_msgs_RobotStateRTMsg.joint_modes.size(); }
	inline bool isJoint_modesEmpty() const { return idl_Ur_msgs_RobotStateRTMsg.joint_modes.empty(); }
	/**
	 * Setter methods for idl_Ur_msgs_RobotStateRTMsg.joint_modes of type vector<double>
	 */
	inline Ur_msgs_RobotStateRTMsgCore& setJoint_modes(const std::vector<double> &joint_modes) { idl_Ur_msgs_RobotStateRTMsg.joint_modes = joint_modes; return *this; }
	inline bool setJoint_modesElemAtPos(const size_t &pos, const double &elem) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.joint_modes.size()) {
			idl_Ur_msgs_RobotStateRTMsg.joint_modes[pos] = elem;
			return true;
		}
		return false;
	}
	inline bool insertJoint_modesVectorAtPos(const size_t &pos, const std::vector<double> &data) {
		if(pos < idl_Ur_msgs_RobotStateRTMsg.joint_modes.size()) {
			idl_Ur_msgs_RobotStateRTMsg.joint_modes.insert(idl_Ur_msgs_RobotStateRTMsg.joint_modes.begin()+pos, data.begin(), data.end());
			return true;
		}
		return false;
	}
	inline void resizeJoint_modes(const size_t &size) { idl_Ur_msgs_RobotStateRTMsg.joint_modes.resize(size); }
	inline bool eraseJoint_modesElemsAtPos(const size_t &pos, const size_t &nbr_elems) {
		if( (pos+nbr_elems) <= idl_Ur_msgs_RobotStateRTMsg.joint_modes.size() ) {
			idl_Ur_msgs_RobotStateRTMsg.joint_modes.erase(idl_Ur_msgs_RobotStateRTMsg.joint_modes.begin()+pos, idl_Ur_msgs_RobotStateRTMsg.joint_modes.begin()+pos+nbr_elems);
			return true;
		}
		return false;
	}
	inline void clearJoint_modes() { idl_Ur_msgs_RobotStateRTMsg.joint_modes.clear(); }
};

} /* namespace ROSUr_msgs */
#endif /* ROSUR_MSGS_UR_MSGS_ROBOTSTATERTMSG_CORE_H_ */
