//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#include "ROSUr_msgs/Ur_msgs_RobotStateRTMsgCore.hh"

// serialization/deserialization operators
//#include "ROSUr_msgs/Ur_msgs_RobotStateRTMsgACE.hh"

// include the hash.idl containing the hash constant
#include "hash.hh"
#include <assert.h>
#include <cstring>
#include <iostream>

// SmartUtils used in from_xml method
#include "smartKnuthMorrisPratt.hh"

#ifdef ENABLE_HASH
	#include <boost/functional/hash.hpp>
#endif

namespace ROSUr_msgs 
{
	const char* Ur_msgs_RobotStateRTMsgCore::getCompiledHash()
	{
		return ROSUr_msgsIDL::REPO_HASH;
	}
	
	void Ur_msgs_RobotStateRTMsgCore::getAllHashValues(std::list<std::string> &hashes)
	{
		// get own hash value
		hashes.push_back(getCompiledHash());
	}
	
	void Ur_msgs_RobotStateRTMsgCore::checkAllHashValues(std::list<std::string> &hashes)
	{
		// check own hash value
		if (strcmp(getCompiledHash(), hashes.front().c_str()) != 0)
		{
			std::cerr << "###################################################" << std::endl;
			std::cerr << "WARNING: HASHES OF COMMUNICATION OBJECTS MISSMATCH!" << std::endl;
			std::cerr << "Ur_msgs_RobotStateRTMsgCore hash" << std::endl;
			std::cerr << "Expected: " << getCompiledHash() << std::endl;
			std::cerr << "Received: " << hashes.front() << std::endl;
			std::cerr << "###################################################" << std::endl;
		}
		assert(strcmp(getCompiledHash(), hashes.front().c_str()) == 0);
		hashes.pop_front();
		
	}
	
	#ifdef ENABLE_HASH
	size_t Ur_msgs_RobotStateRTMsgCore::generateDataHash(const DATATYPE &data)
	{
		size_t seed = 0;
		
		boost::hash_combine(seed, data.time);
		std::vector<ACE_CDR::Double>::const_iterator data_q_targetIt;
		for(data_q_targetIt=data.q_target.begin(); data_q_targetIt!=data.q_target.end(); data_q_targetIt++) {
			boost::hash_combine(seed, *data_q_targetIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_qd_targetIt;
		for(data_qd_targetIt=data.qd_target.begin(); data_qd_targetIt!=data.qd_target.end(); data_qd_targetIt++) {
			boost::hash_combine(seed, *data_qd_targetIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_qdd_targetIt;
		for(data_qdd_targetIt=data.qdd_target.begin(); data_qdd_targetIt!=data.qdd_target.end(); data_qdd_targetIt++) {
			boost::hash_combine(seed, *data_qdd_targetIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_i_targetIt;
		for(data_i_targetIt=data.i_target.begin(); data_i_targetIt!=data.i_target.end(); data_i_targetIt++) {
			boost::hash_combine(seed, *data_i_targetIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_m_targetIt;
		for(data_m_targetIt=data.m_target.begin(); data_m_targetIt!=data.m_target.end(); data_m_targetIt++) {
			boost::hash_combine(seed, *data_m_targetIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_q_actualIt;
		for(data_q_actualIt=data.q_actual.begin(); data_q_actualIt!=data.q_actual.end(); data_q_actualIt++) {
			boost::hash_combine(seed, *data_q_actualIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_qd_actualIt;
		for(data_qd_actualIt=data.qd_actual.begin(); data_qd_actualIt!=data.qd_actual.end(); data_qd_actualIt++) {
			boost::hash_combine(seed, *data_qd_actualIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_i_actualIt;
		for(data_i_actualIt=data.i_actual.begin(); data_i_actualIt!=data.i_actual.end(); data_i_actualIt++) {
			boost::hash_combine(seed, *data_i_actualIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_tool_acc_valuesIt;
		for(data_tool_acc_valuesIt=data.tool_acc_values.begin(); data_tool_acc_valuesIt!=data.tool_acc_values.end(); data_tool_acc_valuesIt++) {
			boost::hash_combine(seed, *data_tool_acc_valuesIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_tcp_forceIt;
		for(data_tcp_forceIt=data.tcp_force.begin(); data_tcp_forceIt!=data.tcp_force.end(); data_tcp_forceIt++) {
			boost::hash_combine(seed, *data_tcp_forceIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_tool_vectorIt;
		for(data_tool_vectorIt=data.tool_vector.begin(); data_tool_vectorIt!=data.tool_vector.end(); data_tool_vectorIt++) {
			boost::hash_combine(seed, *data_tool_vectorIt);
		}
		std::vector<ACE_CDR::Double>::const_iterator data_tcp_speedIt;
		for(data_tcp_speedIt=data.tcp_speed.begin(); data_tcp_speedIt!=data.tcp_speed.end(); data_tcp_speedIt++) {
			boost::hash_combine(seed, *data_tcp_speedIt);
		}
		boost::hash_combine(seed, data.digital_input_bits);
		std::vector<ACE_CDR::Double>::const_iterator data_motor_temperaturesIt;
		for(data_motor_temperaturesIt=data.motor_temperatures.begin(); data_motor_temperaturesIt!=data.motor_temperatures.end(); data_motor_temperaturesIt++) {
			boost::hash_combine(seed, *data_motor_temperaturesIt);
		}
		boost::hash_combine(seed, data.controller_timer);
		boost::hash_combine(seed, data.test_value);
		boost::hash_combine(seed, data.robot_mode);
		std::vector<ACE_CDR::Double>::const_iterator data_joint_modesIt;
		for(data_joint_modesIt=data.joint_modes.begin(); data_joint_modesIt!=data.joint_modes.end(); data_joint_modesIt++) {
			boost::hash_combine(seed, *data_joint_modesIt);
		}
		
		return seed;
	}
	#endif
	
	// default constructor
	Ur_msgs_RobotStateRTMsgCore::Ur_msgs_RobotStateRTMsgCore()
	:	idl_Ur_msgs_RobotStateRTMsg()
	{  
		setTime(0.0);
		setQ_target(std::vector<double>());
		setQd_target(std::vector<double>());
		setQdd_target(std::vector<double>());
		setI_target(std::vector<double>());
		setM_target(std::vector<double>());
		setQ_actual(std::vector<double>());
		setQd_actual(std::vector<double>());
		setI_actual(std::vector<double>());
		setTool_acc_values(std::vector<double>());
		setTcp_force(std::vector<double>());
		setTool_vector(std::vector<double>());
		setTcp_speed(std::vector<double>());
		setDigital_input_bits(0.0);
		setMotor_temperatures(std::vector<double>());
		setController_timer(0.0);
		setTest_value(0.0);
		setRobot_mode(0.0);
		setJoint_modes(std::vector<double>());
	}
	
	Ur_msgs_RobotStateRTMsgCore::Ur_msgs_RobotStateRTMsgCore(const DATATYPE &data)
	:	idl_Ur_msgs_RobotStateRTMsg(data)
	{  }

	Ur_msgs_RobotStateRTMsgCore::~Ur_msgs_RobotStateRTMsgCore()
	{  }
	
	void Ur_msgs_RobotStateRTMsgCore::to_ostream(std::ostream &os) const
	{
	  os << "Ur_msgs_RobotStateRTMsg(";
	  os << getTime() << " ";
	  std::vector<double>::const_iterator q_targetIt;
	  std::vector<double> q_targetList = getQ_targetCopy();
	  for(q_targetIt=q_targetList.begin(); q_targetIt!=q_targetList.end(); q_targetIt++) {
	  	os << *q_targetIt << " ";
	  }
	  std::vector<double>::const_iterator qd_targetIt;
	  std::vector<double> qd_targetList = getQd_targetCopy();
	  for(qd_targetIt=qd_targetList.begin(); qd_targetIt!=qd_targetList.end(); qd_targetIt++) {
	  	os << *qd_targetIt << " ";
	  }
	  std::vector<double>::const_iterator qdd_targetIt;
	  std::vector<double> qdd_targetList = getQdd_targetCopy();
	  for(qdd_targetIt=qdd_targetList.begin(); qdd_targetIt!=qdd_targetList.end(); qdd_targetIt++) {
	  	os << *qdd_targetIt << " ";
	  }
	  std::vector<double>::const_iterator i_targetIt;
	  std::vector<double> i_targetList = getI_targetCopy();
	  for(i_targetIt=i_targetList.begin(); i_targetIt!=i_targetList.end(); i_targetIt++) {
	  	os << *i_targetIt << " ";
	  }
	  std::vector<double>::const_iterator m_targetIt;
	  std::vector<double> m_targetList = getM_targetCopy();
	  for(m_targetIt=m_targetList.begin(); m_targetIt!=m_targetList.end(); m_targetIt++) {
	  	os << *m_targetIt << " ";
	  }
	  std::vector<double>::const_iterator q_actualIt;
	  std::vector<double> q_actualList = getQ_actualCopy();
	  for(q_actualIt=q_actualList.begin(); q_actualIt!=q_actualList.end(); q_actualIt++) {
	  	os << *q_actualIt << " ";
	  }
	  std::vector<double>::const_iterator qd_actualIt;
	  std::vector<double> qd_actualList = getQd_actualCopy();
	  for(qd_actualIt=qd_actualList.begin(); qd_actualIt!=qd_actualList.end(); qd_actualIt++) {
	  	os << *qd_actualIt << " ";
	  }
	  std::vector<double>::const_iterator i_actualIt;
	  std::vector<double> i_actualList = getI_actualCopy();
	  for(i_actualIt=i_actualList.begin(); i_actualIt!=i_actualList.end(); i_actualIt++) {
	  	os << *i_actualIt << " ";
	  }
	  std::vector<double>::const_iterator tool_acc_valuesIt;
	  std::vector<double> tool_acc_valuesList = getTool_acc_valuesCopy();
	  for(tool_acc_valuesIt=tool_acc_valuesList.begin(); tool_acc_valuesIt!=tool_acc_valuesList.end(); tool_acc_valuesIt++) {
	  	os << *tool_acc_valuesIt << " ";
	  }
	  std::vector<double>::const_iterator tcp_forceIt;
	  std::vector<double> tcp_forceList = getTcp_forceCopy();
	  for(tcp_forceIt=tcp_forceList.begin(); tcp_forceIt!=tcp_forceList.end(); tcp_forceIt++) {
	  	os << *tcp_forceIt << " ";
	  }
	  std::vector<double>::const_iterator tool_vectorIt;
	  std::vector<double> tool_vectorList = getTool_vectorCopy();
	  for(tool_vectorIt=tool_vectorList.begin(); tool_vectorIt!=tool_vectorList.end(); tool_vectorIt++) {
	  	os << *tool_vectorIt << " ";
	  }
	  std::vector<double>::const_iterator tcp_speedIt;
	  std::vector<double> tcp_speedList = getTcp_speedCopy();
	  for(tcp_speedIt=tcp_speedList.begin(); tcp_speedIt!=tcp_speedList.end(); tcp_speedIt++) {
	  	os << *tcp_speedIt << " ";
	  }
	  os << getDigital_input_bits() << " ";
	  std::vector<double>::const_iterator motor_temperaturesIt;
	  std::vector<double> motor_temperaturesList = getMotor_temperaturesCopy();
	  for(motor_temperaturesIt=motor_temperaturesList.begin(); motor_temperaturesIt!=motor_temperaturesList.end(); motor_temperaturesIt++) {
	  	os << *motor_temperaturesIt << " ";
	  }
	  os << getController_timer() << " ";
	  os << getTest_value() << " ";
	  os << getRobot_mode() << " ";
	  std::vector<double>::const_iterator joint_modesIt;
	  std::vector<double> joint_modesList = getJoint_modesCopy();
	  for(joint_modesIt=joint_modesList.begin(); joint_modesIt!=joint_modesList.end(); joint_modesIt++) {
	  	os << *joint_modesIt << " ";
	  }
	  os << ") ";
	}
	
	// convert to xml stream
	void Ur_msgs_RobotStateRTMsgCore::to_xml(std::ostream &os, const std::string &indent) const {
		size_t counter = 0;
		
		os << indent << "<time>" << getTime() << "</time>";
		std::vector<double>::const_iterator q_targetIt;
		std::vector<double> q_targetList = getQ_targetCopy();
		counter = 0;
		os << indent << "<q_targetList n=\"" << q_targetList.size() << "\">";
		for(q_targetIt=q_targetList.begin(); q_targetIt!=q_targetList.end(); q_targetIt++) {
			os << indent << "<q_target i=\"" << counter++ << "\">" << *q_targetIt << "</q_target>";
		}
		os << indent << "</q_targetList>";
		std::vector<double>::const_iterator qd_targetIt;
		std::vector<double> qd_targetList = getQd_targetCopy();
		counter = 0;
		os << indent << "<qd_targetList n=\"" << qd_targetList.size() << "\">";
		for(qd_targetIt=qd_targetList.begin(); qd_targetIt!=qd_targetList.end(); qd_targetIt++) {
			os << indent << "<qd_target i=\"" << counter++ << "\">" << *qd_targetIt << "</qd_target>";
		}
		os << indent << "</qd_targetList>";
		std::vector<double>::const_iterator qdd_targetIt;
		std::vector<double> qdd_targetList = getQdd_targetCopy();
		counter = 0;
		os << indent << "<qdd_targetList n=\"" << qdd_targetList.size() << "\">";
		for(qdd_targetIt=qdd_targetList.begin(); qdd_targetIt!=qdd_targetList.end(); qdd_targetIt++) {
			os << indent << "<qdd_target i=\"" << counter++ << "\">" << *qdd_targetIt << "</qdd_target>";
		}
		os << indent << "</qdd_targetList>";
		std::vector<double>::const_iterator i_targetIt;
		std::vector<double> i_targetList = getI_targetCopy();
		counter = 0;
		os << indent << "<i_targetList n=\"" << i_targetList.size() << "\">";
		for(i_targetIt=i_targetList.begin(); i_targetIt!=i_targetList.end(); i_targetIt++) {
			os << indent << "<i_target i=\"" << counter++ << "\">" << *i_targetIt << "</i_target>";
		}
		os << indent << "</i_targetList>";
		std::vector<double>::const_iterator m_targetIt;
		std::vector<double> m_targetList = getM_targetCopy();
		counter = 0;
		os << indent << "<m_targetList n=\"" << m_targetList.size() << "\">";
		for(m_targetIt=m_targetList.begin(); m_targetIt!=m_targetList.end(); m_targetIt++) {
			os << indent << "<m_target i=\"" << counter++ << "\">" << *m_targetIt << "</m_target>";
		}
		os << indent << "</m_targetList>";
		std::vector<double>::const_iterator q_actualIt;
		std::vector<double> q_actualList = getQ_actualCopy();
		counter = 0;
		os << indent << "<q_actualList n=\"" << q_actualList.size() << "\">";
		for(q_actualIt=q_actualList.begin(); q_actualIt!=q_actualList.end(); q_actualIt++) {
			os << indent << "<q_actual i=\"" << counter++ << "\">" << *q_actualIt << "</q_actual>";
		}
		os << indent << "</q_actualList>";
		std::vector<double>::const_iterator qd_actualIt;
		std::vector<double> qd_actualList = getQd_actualCopy();
		counter = 0;
		os << indent << "<qd_actualList n=\"" << qd_actualList.size() << "\">";
		for(qd_actualIt=qd_actualList.begin(); qd_actualIt!=qd_actualList.end(); qd_actualIt++) {
			os << indent << "<qd_actual i=\"" << counter++ << "\">" << *qd_actualIt << "</qd_actual>";
		}
		os << indent << "</qd_actualList>";
		std::vector<double>::const_iterator i_actualIt;
		std::vector<double> i_actualList = getI_actualCopy();
		counter = 0;
		os << indent << "<i_actualList n=\"" << i_actualList.size() << "\">";
		for(i_actualIt=i_actualList.begin(); i_actualIt!=i_actualList.end(); i_actualIt++) {
			os << indent << "<i_actual i=\"" << counter++ << "\">" << *i_actualIt << "</i_actual>";
		}
		os << indent << "</i_actualList>";
		std::vector<double>::const_iterator tool_acc_valuesIt;
		std::vector<double> tool_acc_valuesList = getTool_acc_valuesCopy();
		counter = 0;
		os << indent << "<tool_acc_valuesList n=\"" << tool_acc_valuesList.size() << "\">";
		for(tool_acc_valuesIt=tool_acc_valuesList.begin(); tool_acc_valuesIt!=tool_acc_valuesList.end(); tool_acc_valuesIt++) {
			os << indent << "<tool_acc_values i=\"" << counter++ << "\">" << *tool_acc_valuesIt << "</tool_acc_values>";
		}
		os << indent << "</tool_acc_valuesList>";
		std::vector<double>::const_iterator tcp_forceIt;
		std::vector<double> tcp_forceList = getTcp_forceCopy();
		counter = 0;
		os << indent << "<tcp_forceList n=\"" << tcp_forceList.size() << "\">";
		for(tcp_forceIt=tcp_forceList.begin(); tcp_forceIt!=tcp_forceList.end(); tcp_forceIt++) {
			os << indent << "<tcp_force i=\"" << counter++ << "\">" << *tcp_forceIt << "</tcp_force>";
		}
		os << indent << "</tcp_forceList>";
		std::vector<double>::const_iterator tool_vectorIt;
		std::vector<double> tool_vectorList = getTool_vectorCopy();
		counter = 0;
		os << indent << "<tool_vectorList n=\"" << tool_vectorList.size() << "\">";
		for(tool_vectorIt=tool_vectorList.begin(); tool_vectorIt!=tool_vectorList.end(); tool_vectorIt++) {
			os << indent << "<tool_vector i=\"" << counter++ << "\">" << *tool_vectorIt << "</tool_vector>";
		}
		os << indent << "</tool_vectorList>";
		std::vector<double>::const_iterator tcp_speedIt;
		std::vector<double> tcp_speedList = getTcp_speedCopy();
		counter = 0;
		os << indent << "<tcp_speedList n=\"" << tcp_speedList.size() << "\">";
		for(tcp_speedIt=tcp_speedList.begin(); tcp_speedIt!=tcp_speedList.end(); tcp_speedIt++) {
			os << indent << "<tcp_speed i=\"" << counter++ << "\">" << *tcp_speedIt << "</tcp_speed>";
		}
		os << indent << "</tcp_speedList>";
		os << indent << "<digital_input_bits>" << getDigital_input_bits() << "</digital_input_bits>";
		std::vector<double>::const_iterator motor_temperaturesIt;
		std::vector<double> motor_temperaturesList = getMotor_temperaturesCopy();
		counter = 0;
		os << indent << "<motor_temperaturesList n=\"" << motor_temperaturesList.size() << "\">";
		for(motor_temperaturesIt=motor_temperaturesList.begin(); motor_temperaturesIt!=motor_temperaturesList.end(); motor_temperaturesIt++) {
			os << indent << "<motor_temperatures i=\"" << counter++ << "\">" << *motor_temperaturesIt << "</motor_temperatures>";
		}
		os << indent << "</motor_temperaturesList>";
		os << indent << "<controller_timer>" << getController_timer() << "</controller_timer>";
		os << indent << "<test_value>" << getTest_value() << "</test_value>";
		os << indent << "<robot_mode>" << getRobot_mode() << "</robot_mode>";
		std::vector<double>::const_iterator joint_modesIt;
		std::vector<double> joint_modesList = getJoint_modesCopy();
		counter = 0;
		os << indent << "<joint_modesList n=\"" << joint_modesList.size() << "\">";
		for(joint_modesIt=joint_modesList.begin(); joint_modesIt!=joint_modesList.end(); joint_modesIt++) {
			os << indent << "<joint_modes i=\"" << counter++ << "\">" << *joint_modesIt << "</joint_modes>";
		}
		os << indent << "</joint_modesList>";
	}
	
	// restore from xml stream
	void Ur_msgs_RobotStateRTMsgCore::from_xml(std::istream &is) {
		size_t counter = 0;
		
		static const Smart::KnuthMorrisPratt kmp_time("<time>");
		static const Smart::KnuthMorrisPratt kmp_q_targetList("<q_targetList n=\"");
		static const Smart::KnuthMorrisPratt kmp_q_target("\">");
		static const Smart::KnuthMorrisPratt kmp_qd_targetList("<qd_targetList n=\"");
		static const Smart::KnuthMorrisPratt kmp_qd_target("\">");
		static const Smart::KnuthMorrisPratt kmp_qdd_targetList("<qdd_targetList n=\"");
		static const Smart::KnuthMorrisPratt kmp_qdd_target("\">");
		static const Smart::KnuthMorrisPratt kmp_i_targetList("<i_targetList n=\"");
		static const Smart::KnuthMorrisPratt kmp_i_target("\">");
		static const Smart::KnuthMorrisPratt kmp_m_targetList("<m_targetList n=\"");
		static const Smart::KnuthMorrisPratt kmp_m_target("\">");
		static const Smart::KnuthMorrisPratt kmp_q_actualList("<q_actualList n=\"");
		static const Smart::KnuthMorrisPratt kmp_q_actual("\">");
		static const Smart::KnuthMorrisPratt kmp_qd_actualList("<qd_actualList n=\"");
		static const Smart::KnuthMorrisPratt kmp_qd_actual("\">");
		static const Smart::KnuthMorrisPratt kmp_i_actualList("<i_actualList n=\"");
		static const Smart::KnuthMorrisPratt kmp_i_actual("\">");
		static const Smart::KnuthMorrisPratt kmp_tool_acc_valuesList("<tool_acc_valuesList n=\"");
		static const Smart::KnuthMorrisPratt kmp_tool_acc_values("\">");
		static const Smart::KnuthMorrisPratt kmp_tcp_forceList("<tcp_forceList n=\"");
		static const Smart::KnuthMorrisPratt kmp_tcp_force("\">");
		static const Smart::KnuthMorrisPratt kmp_tool_vectorList("<tool_vectorList n=\"");
		static const Smart::KnuthMorrisPratt kmp_tool_vector("\">");
		static const Smart::KnuthMorrisPratt kmp_tcp_speedList("<tcp_speedList n=\"");
		static const Smart::KnuthMorrisPratt kmp_tcp_speed("\">");
		static const Smart::KnuthMorrisPratt kmp_digital_input_bits("<digital_input_bits>");
		static const Smart::KnuthMorrisPratt kmp_motor_temperaturesList("<motor_temperaturesList n=\"");
		static const Smart::KnuthMorrisPratt kmp_motor_temperatures("\">");
		static const Smart::KnuthMorrisPratt kmp_controller_timer("<controller_timer>");
		static const Smart::KnuthMorrisPratt kmp_test_value("<test_value>");
		static const Smart::KnuthMorrisPratt kmp_robot_mode("<robot_mode>");
		static const Smart::KnuthMorrisPratt kmp_joint_modesList("<joint_modesList n=\"");
		static const Smart::KnuthMorrisPratt kmp_joint_modes("\">");
		
		if(kmp_time.search(is)) {
			double timeItem;
			is >> timeItem;
			setTime(timeItem);
		}
		if(kmp_q_targetList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double q_targetItem;
			std::vector<double> q_targetList;
			kmp_q_target.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_q_target.search(is)) {
					is >> q_targetItem;
					q_targetList.push_back(q_targetItem);
				}
			}
			setQ_target(q_targetList);
		}
		if(kmp_qd_targetList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double qd_targetItem;
			std::vector<double> qd_targetList;
			kmp_qd_target.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_qd_target.search(is)) {
					is >> qd_targetItem;
					qd_targetList.push_back(qd_targetItem);
				}
			}
			setQd_target(qd_targetList);
		}
		if(kmp_qdd_targetList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double qdd_targetItem;
			std::vector<double> qdd_targetList;
			kmp_qdd_target.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_qdd_target.search(is)) {
					is >> qdd_targetItem;
					qdd_targetList.push_back(qdd_targetItem);
				}
			}
			setQdd_target(qdd_targetList);
		}
		if(kmp_i_targetList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double i_targetItem;
			std::vector<double> i_targetList;
			kmp_i_target.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_i_target.search(is)) {
					is >> i_targetItem;
					i_targetList.push_back(i_targetItem);
				}
			}
			setI_target(i_targetList);
		}
		if(kmp_m_targetList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double m_targetItem;
			std::vector<double> m_targetList;
			kmp_m_target.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_m_target.search(is)) {
					is >> m_targetItem;
					m_targetList.push_back(m_targetItem);
				}
			}
			setM_target(m_targetList);
		}
		if(kmp_q_actualList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double q_actualItem;
			std::vector<double> q_actualList;
			kmp_q_actual.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_q_actual.search(is)) {
					is >> q_actualItem;
					q_actualList.push_back(q_actualItem);
				}
			}
			setQ_actual(q_actualList);
		}
		if(kmp_qd_actualList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double qd_actualItem;
			std::vector<double> qd_actualList;
			kmp_qd_actual.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_qd_actual.search(is)) {
					is >> qd_actualItem;
					qd_actualList.push_back(qd_actualItem);
				}
			}
			setQd_actual(qd_actualList);
		}
		if(kmp_i_actualList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double i_actualItem;
			std::vector<double> i_actualList;
			kmp_i_actual.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_i_actual.search(is)) {
					is >> i_actualItem;
					i_actualList.push_back(i_actualItem);
				}
			}
			setI_actual(i_actualList);
		}
		if(kmp_tool_acc_valuesList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double tool_acc_valuesItem;
			std::vector<double> tool_acc_valuesList;
			kmp_tool_acc_values.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_tool_acc_values.search(is)) {
					is >> tool_acc_valuesItem;
					tool_acc_valuesList.push_back(tool_acc_valuesItem);
				}
			}
			setTool_acc_values(tool_acc_valuesList);
		}
		if(kmp_tcp_forceList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double tcp_forceItem;
			std::vector<double> tcp_forceList;
			kmp_tcp_force.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_tcp_force.search(is)) {
					is >> tcp_forceItem;
					tcp_forceList.push_back(tcp_forceItem);
				}
			}
			setTcp_force(tcp_forceList);
		}
		if(kmp_tool_vectorList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double tool_vectorItem;
			std::vector<double> tool_vectorList;
			kmp_tool_vector.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_tool_vector.search(is)) {
					is >> tool_vectorItem;
					tool_vectorList.push_back(tool_vectorItem);
				}
			}
			setTool_vector(tool_vectorList);
		}
		if(kmp_tcp_speedList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double tcp_speedItem;
			std::vector<double> tcp_speedList;
			kmp_tcp_speed.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_tcp_speed.search(is)) {
					is >> tcp_speedItem;
					tcp_speedList.push_back(tcp_speedItem);
				}
			}
			setTcp_speed(tcp_speedList);
		}
		if(kmp_digital_input_bits.search(is)) {
			double digital_input_bitsItem;
			is >> digital_input_bitsItem;
			setDigital_input_bits(digital_input_bitsItem);
		}
		if(kmp_motor_temperaturesList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double motor_temperaturesItem;
			std::vector<double> motor_temperaturesList;
			kmp_motor_temperatures.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_motor_temperatures.search(is)) {
					is >> motor_temperaturesItem;
					motor_temperaturesList.push_back(motor_temperaturesItem);
				}
			}
			setMotor_temperatures(motor_temperaturesList);
		}
		if(kmp_controller_timer.search(is)) {
			double controller_timerItem;
			is >> controller_timerItem;
			setController_timer(controller_timerItem);
		}
		if(kmp_test_value.search(is)) {
			double test_valueItem;
			is >> test_valueItem;
			setTest_value(test_valueItem);
		}
		if(kmp_robot_mode.search(is)) {
			double robot_modeItem;
			is >> robot_modeItem;
			setRobot_mode(robot_modeItem);
		}
		if(kmp_joint_modesList.search(is)) {
			size_t numberElements;
			is >> numberElements;
			double joint_modesItem;
			std::vector<double> joint_modesList;
			kmp_joint_modes.search(is);
			for(counter=0; counter<numberElements; counter++) {
				if(kmp_joint_modes.search(is)) {
					is >> joint_modesItem;
					joint_modesList.push_back(joint_modesItem);
				}
			}
			setJoint_modes(joint_modesList);
		}
	}
	
	/*
	void Ur_msgs_RobotStateRTMsgCore::get(ACE_Message_Block *&msg) const
	{
		// start with a default internal buffer size(will automatically grow if needed)
		ACE_OutputCDR cdr(ACE_DEFAULT_CDR_BUFSIZE);
		
		ROSUr_msgsIDL::HashList hashes;
		getAllHashValues(hashes);
		cdr << static_cast<ACE_CDR::Long>(hashes.size());
		for(ROSUr_msgsIDL::HashList::const_iterator it=hashes.begin(); it!=hashes.end(); it++)
		{
			cdr << ACE_CString(it->c_str());
		}
		
		// Here the actual serialization takes place using the OutputCDR serialization operator<<
		// (see Ur_msgs_RobotStateRTMsgACE.hh)
		cdr << idl_Ur_msgs_RobotStateRTMsg;
		
	#ifdef ENABLE_HASH
		ACE_CDR::ULong data_hash = generateDataHash(idl_Ur_msgs_RobotStateRTMsg);
		cdr << data_hash;
		// std::cout << "Ur_msgs_RobotStateRTMsgCore: current data hash: " << data_hash << std::endl;
	#endif
		
		// return a shallow copy of the serialized message 
		// (no data is actually copied, only the internal reference counter is incremented)
		// in order to prevent memory leaks the caller of this get(msg) method must
		// manually free the memory by calling the release() method of the message block msg
		msg = cdr.begin()->duplicate();
	}
	
	void Ur_msgs_RobotStateRTMsgCore::set(const ACE_Message_Block *msg)
	{
		ACE_InputCDR cdr(msg);
	
		ROSUr_msgsIDL::HashList hashes;
		ACE_CDR::Long hashes_size;
		cdr >> hashes_size;
		for(int i=0; i<hashes_size; ++i) 
		{
			ACE_CString hash;
			cdr >> hash;
			hashes.push_back(hash.c_str());
		}
		checkAllHashValues(hashes);
		
		// Here the actual de-serialization takes place using the InputCDR serialization operator>>
		// (see Ur_msgs_RobotStateRTMsgACE.hh)
		cdr >> idl_Ur_msgs_RobotStateRTMsg;
		
	#ifdef ENABLE_HASH
		ACE_CDR::Long data_hash;
		cdr >> data_hash;
		ACE_CDR::Long own_hash = generateDataHash(idl_Ur_msgs_RobotStateRTMsg);
		assert(data_hash == own_hash);
		// std::cout << "Ur_msgs_RobotStateRTMsgCore: own data hash: " << own_hash << "; received data hash: " << data_hash << std::endl;
	#endif
	}
	*/
} /* namespace ROSUr_msgs */
