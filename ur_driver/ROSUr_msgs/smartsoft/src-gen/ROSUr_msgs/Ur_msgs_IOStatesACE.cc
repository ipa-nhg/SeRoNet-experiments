//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#include "ROSUr_msgs/Ur_msgs_IOStatesACE.hh"
#include <ace/SString.h>
#include "ROSUr_msgs/Ur_msgs_AnalogACE.hh"
#include "ROSUr_msgs/Ur_msgs_DigitalACE.hh"

// serialization operator for element Ur_msgs_IOStates
ACE_CDR::Boolean operator<<(ACE_OutputCDR &cdr, const ROSUr_msgsIDL::Ur_msgs_IOStates &data)
{
	ACE_CDR::Boolean good_bit = true;
	// serialize list-element digital_in_states
	good_bit = good_bit && cdr << ACE_Utils::truncate_cast<ACE_CDR::ULong>(data.digital_in_states.size());
	std::vector<ROSUr_msgsIDL::Ur_msgs_Digital>::const_iterator data_digital_in_statesIt;
	for(data_digital_in_statesIt=data.digital_in_states.begin(); data_digital_in_statesIt!=data.digital_in_states.end(); data_digital_in_statesIt++) {
		good_bit = good_bit && cdr << *data_digital_in_statesIt;
	}
	// serialize list-element digital_out_states
	good_bit = good_bit && cdr << ACE_Utils::truncate_cast<ACE_CDR::ULong>(data.digital_out_states.size());
	std::vector<ROSUr_msgsIDL::Ur_msgs_Digital>::const_iterator data_digital_out_statesIt;
	for(data_digital_out_statesIt=data.digital_out_states.begin(); data_digital_out_statesIt!=data.digital_out_states.end(); data_digital_out_statesIt++) {
		good_bit = good_bit && cdr << *data_digital_out_statesIt;
	}
	// serialize list-element flag_states
	good_bit = good_bit && cdr << ACE_Utils::truncate_cast<ACE_CDR::ULong>(data.flag_states.size());
	std::vector<ROSUr_msgsIDL::Ur_msgs_Digital>::const_iterator data_flag_statesIt;
	for(data_flag_statesIt=data.flag_states.begin(); data_flag_statesIt!=data.flag_states.end(); data_flag_statesIt++) {
		good_bit = good_bit && cdr << *data_flag_statesIt;
	}
	// serialize list-element analog_in_states
	good_bit = good_bit && cdr << ACE_Utils::truncate_cast<ACE_CDR::ULong>(data.analog_in_states.size());
	std::vector<ROSUr_msgsIDL::Ur_msgs_Analog>::const_iterator data_analog_in_statesIt;
	for(data_analog_in_statesIt=data.analog_in_states.begin(); data_analog_in_statesIt!=data.analog_in_states.end(); data_analog_in_statesIt++) {
		good_bit = good_bit && cdr << *data_analog_in_statesIt;
	}
	// serialize list-element analog_out_states
	good_bit = good_bit && cdr << ACE_Utils::truncate_cast<ACE_CDR::ULong>(data.analog_out_states.size());
	std::vector<ROSUr_msgsIDL::Ur_msgs_Analog>::const_iterator data_analog_out_statesIt;
	for(data_analog_out_statesIt=data.analog_out_states.begin(); data_analog_out_statesIt!=data.analog_out_states.end(); data_analog_out_statesIt++) {
		good_bit = good_bit && cdr << *data_analog_out_statesIt;
	}
	
	return good_bit;
}

// de-serialization operator for element Ur_msgs_IOStates
ACE_CDR::Boolean operator>>(ACE_InputCDR &cdr, ROSUr_msgsIDL::Ur_msgs_IOStates &data)
{
	ACE_CDR::Boolean good_bit = true;
	// deserialize list-type element digital_in_states
	ACE_CDR::ULong data_digital_in_statesNbr;
	good_bit = good_bit && cdr >> data_digital_in_statesNbr;
	data.digital_in_states.clear();
	ROSUr_msgsIDL::Ur_msgs_Digital data_digital_in_statesItem;
	for(ACE_CDR::ULong i=0; i<data_digital_in_statesNbr; ++i) {
		good_bit = good_bit && cdr >> data_digital_in_statesItem;
		data.digital_in_states.push_back(data_digital_in_statesItem);
	}
	// deserialize list-type element digital_out_states
	ACE_CDR::ULong data_digital_out_statesNbr;
	good_bit = good_bit && cdr >> data_digital_out_statesNbr;
	data.digital_out_states.clear();
	ROSUr_msgsIDL::Ur_msgs_Digital data_digital_out_statesItem;
	for(ACE_CDR::ULong i=0; i<data_digital_out_statesNbr; ++i) {
		good_bit = good_bit && cdr >> data_digital_out_statesItem;
		data.digital_out_states.push_back(data_digital_out_statesItem);
	}
	// deserialize list-type element flag_states
	ACE_CDR::ULong data_flag_statesNbr;
	good_bit = good_bit && cdr >> data_flag_statesNbr;
	data.flag_states.clear();
	ROSUr_msgsIDL::Ur_msgs_Digital data_flag_statesItem;
	for(ACE_CDR::ULong i=0; i<data_flag_statesNbr; ++i) {
		good_bit = good_bit && cdr >> data_flag_statesItem;
		data.flag_states.push_back(data_flag_statesItem);
	}
	// deserialize list-type element analog_in_states
	ACE_CDR::ULong data_analog_in_statesNbr;
	good_bit = good_bit && cdr >> data_analog_in_statesNbr;
	data.analog_in_states.clear();
	ROSUr_msgsIDL::Ur_msgs_Analog data_analog_in_statesItem;
	for(ACE_CDR::ULong i=0; i<data_analog_in_statesNbr; ++i) {
		good_bit = good_bit && cdr >> data_analog_in_statesItem;
		data.analog_in_states.push_back(data_analog_in_statesItem);
	}
	// deserialize list-type element analog_out_states
	ACE_CDR::ULong data_analog_out_statesNbr;
	good_bit = good_bit && cdr >> data_analog_out_statesNbr;
	data.analog_out_states.clear();
	ROSUr_msgsIDL::Ur_msgs_Analog data_analog_out_statesItem;
	for(ACE_CDR::ULong i=0; i<data_analog_out_statesNbr; ++i) {
		good_bit = good_bit && cdr >> data_analog_out_statesItem;
		data.analog_out_states.push_back(data_analog_out_statesItem);
	}
	
	return good_bit;
}

// serialization operator for CommunicationObject Ur_msgs_IOStates
ACE_CDR::Boolean operator<<(ACE_OutputCDR &cdr, const ROSUr_msgs::Ur_msgs_IOStates &obj)
{
	return cdr << obj.get();
}

// de-serialization operator for CommunicationObject Ur_msgs_IOStates
ACE_CDR::Boolean operator>>(ACE_InputCDR &cdr, ROSUr_msgs::Ur_msgs_IOStates &obj)
{
	return cdr >> obj.set();
}
